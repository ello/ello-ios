// Generated by Apple Swift version 3.0.2 (swiftlang-800.0.63 clang-800.0.42.1)
#pragma clang diagnostic push

#if defined(__has_include) && __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <objc/NSObject.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if defined(__has_include) && __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus) || __cplusplus < 201103L
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if defined(__has_attribute) && __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if defined(__has_attribute) && __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if defined(__has_attribute) && __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if defined(__has_attribute) && __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if defined(__has_attribute) && __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if defined(__has_attribute) && __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name) enum _name : _type _name; enum SWIFT_ENUM_EXTRA _name : _type
# if defined(__has_feature) && __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME) SWIFT_ENUM(_type, _name)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if defined(__has_feature) && __has_feature(modules)
@import ObjectiveC;
@import CocoaAsyncSocket;
@import Foundation;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"

/**
  \code
  CaffeineHTTPProxy
  \endcode hooks into the iOS URL loading system to accelerate the network requests you specify using \code
  allow:
  \endcode and \code
  deny:
  \endcode.
  The Caffeine API consists of 3 main functions: \code
  start
  \endcode, \code
  allow:
  \endcode, and \code
  deny:
  \endcode
  This class is packaged inside the \code
  Proxeine
  \endcode module, so it must be imported into your App Delegate.
  To a Swift project:
  \code
     import Proxeine

  \endcodeTo an Objective-C Project:
  \code
     import "Proxeine-Swift.h"

  \endcodeBy Default, Caffeine is added to all instances of NSURLSessionConfiguration.defaultSessionConfiguration().
  Caffeine will work alongside networking libraries such as Alamofire or AFNetworking.
  This class uses the open source CocoaAsyncSocket library’s \code
  GCDAsyncUdpSocketDelegate
  \endcode protocol for frictionless UDP-diagnostic logging.
  note:
  If at any time you require help, please contact our engineers at help@caffei.net
  warning:
  NSURLSessions that do not use \code
  NSURLSession.sharedSession()
  \endcode or the \code
  NSURLSessionConfiguration.defaultSessionConfiguration
  \endcode should call \code
  addCaffeine
  \endcode on their session configurations.
*/
SWIFT_CLASS("_TtC8Proxeine17CaffeineHTTPProxy")
@interface CaffeineHTTPProxy : NSObject <GCDAsyncUdpSocketDelegate>
/**
  This is the name of a notification posted to the default notification center after Caffeine has received its remote configuration file. The userInfo dictionary of the notification contains the boolean value of whether or not the current session is using Caffeine keyed by this same notification name. This can be used to track whether the current session uses Caffeine or not.
  A Swift 3 in a View Controller:
  \code
  import UIKit
  import Proxeine

  class ViewController: UIViewController {

      override func viewDidLoad() {
          super.viewDidLoad()
          NotificationCenter.default.addObserver(self, selector: #selector(receivedCaffeineNotification(aNotification:)), name: NSNotification.Name(rawValue: CaffeineHTTPProxy.caffeineInformationStringNotificationKey), object: nil)
      }
      
      // Our method to receive the Caffeine notification
      func receivedCaffeineNotification(aNotification: NSNotification) {
          if aNotification.name.rawValue == CaffeineHTTPProxy.caffeineInformationStringNotificationKey {
              if let usingCaffeine = aNotification.userInfo?[CaffeineHTTPProxy.caffeineInformationStringNotificationKey] as? Bool {
                  // 'usingCaffeine` now tracks whether Caffeine is enabled for this SESSION
                  // You can log this value with your analytics service
              }
          }
      }
      
      deinit {
          NotificationCenter.default.removeObserver(self)
      }
  }

  \endcodeA Swift 2 example in an App Delegate:
  \code
  import UIKit
  import Proxeine

  @UIApplicationMain
  class AppDelegate: UIResponder, UIApplicationDelegate {

      var window: UIWindow?

      func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -> Bool {
          CaffeineHTTPProxy.allow("http://google.com/")
          CaffeineHTTPProxy.start()

          // Start listening for the Caffeine notification

          NSNotificationCenter.defaultCenter().addObserver(self, selector: #selector(AppDelegate.receivedCaffeineNotification(_:)), name: CaffeineHTTPProxy.caffeineInformationStringNotificationKey, object: nil)
              return true
      }


      // Our method to receive the Caffeine notification
      // Called after downloading the percentage value from a remote server
          func receivedCaffeineNotification(aNotification: NSNotification) {
          if aNotification.name == CaffeineHTTPProxy.caffeineInformationStringNotificationKey {
              if let usingCaffeine = aNotification.userInfo?[CaffeineHTTPProxy.caffeineInformationStringNotificationKey] as? Bool {
                  // 'usingCaffeine` now tracks whether Caffeine is enabled for this SESSION
                  // Log this value to your 3rd party analytics service
              }
          }
      }
  }


  \endcode*/
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull caffeineInformationStringNotificationKey;)
+ (NSString * _Nonnull)caffeineInformationStringNotificationKey;
/**
  Starts Caffeine. \code
  start
  \endcode should be called first in your App Delegate’s \code
  application:didFinishLaunchingWithOptions:
  \endcode function.
  By default, no requests are Caffeinated. To Caffeinate a request, it must be explicitly allowed using \code
  allow:
  \endcode.
  Swift 3:
  \code
  import Proxeine
  func applicationDidFinishLaunching(_ application: UIApplication) {
     CaffeineHTTPProxy.start()
     //enter `allow` and `deny` filters here
  }

  \endcodeSwift 2.3:
  \code
     import Proxeine
     func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -> Bool {
         CaffeineHTTPProxy.start()
         //enter `allow` and `deny` filters here
     }

  \endcodeObjective-C:
  \code
     import "Proxeine-Swift.h"
     - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
         [CaffeineHTTPProxy start];
         //enter `allow` and `deny` filters here
     }

  \endcodewarning:
  Calling this function twice is undefined.
  complexity:
  This function is asynchronous and returns immediately.
  seealso:
  \code
  allow:
  \endcode, \code
  deny:
  \endcode
*/
+ (void)start;
+ (void)startWithDebug:(BOOL)debug;
/**
  allow: Caffeinates specific URLs or sets of URLs. No requests will be proxied unless their URL is allowed. Call \code
  allow
  \endcode inside your AppDelegate, within the \code
  application:didFinishLaunchingWithOptions:
  \endcode function.
  Swift:
  \code
     CaffeineHTTPProxy.allow("*.png")
     CaffeineHTTPProxy.allow("https://google.com*")
     CaffeineHTTPProxy.allow("http:*")
     CaffeineHTTPProxy.allow("http://google.com/humans.txt")

  \endcodeObjective-C:
  \code
    [CaffeineHTTPProxy allow:@"*.png"];
    [CaffeineHTTPProxy allow:@"https://google.com*"];
    [CaffeineHTTPProxy allow:@"http:*"];
    [CaffeineHTTPProxy allow:@"http://google.com/humans.txt"];

  \endcodeThis allow configurations (above) specify that the following will be Caffeinated:
  <ul>
    <li>
      all PNG files
    </li>
    <li>
      all HTTPS traffic as long as it STARTS WITH https://google.com/ (not subdomains ie. cats.google.com/)
    </li>
    <li>
      all HTTP traffic (not a recommended filter)
    </li>
    <li>
      the specific HTTP URL: http://google.com/humans.txt
    </li>
  </ul>
*/
+ (void)allow:(NSString * _Nonnull)path;
/**
  deny: Decaffeinates specific URLs or sets of URLs. \code
  deny
  \endcode overrides \code
  allow
  \endcode. No requests will be proxied if their URL is within a deny clause. Call \code
  deny
  \endcode inside your AppDelegate, within the \code
  application:didFinishLaunchingWithOptions:
  \endcode function.
  Swift:
  \code
  CaffeineHTTPProxy.deny("*.png")
  CaffeineHTTPProxy.deny("https://google.com*")
  CaffeineHTTPProxy.deny("http:*")
  CaffeineHTTPProxy.deny("http://google.com/humans.txt")

  \endcodeObjective-C:
  \code
  [CaffeineHTTPProxy deny:@"*.png"];
  [CaffeineHTTPProxy deny:@"https://google.com*"];
  [CaffeineHTTPProxy deny:@"http:*"];
  [CaffeineHTTPProxy deny:@"http://google.com/humans.txt"];

  \endcodeThis allow configurations (above) specify that the following will NOT be Caffeinated:
  <ul>
    <li>
      all PNG files
    </li>
    <li>
      all HTTPS traffic as long as it STARTS WITH https://google.com/ (NOT subdomains ie. cats.google.com/)
    </li>
    <li>
      all HTTP traffic (not a recommended filter)
    </li>
    <li>
      the specific HTTP URL: http://google.com/humans.txt
    </li>
  </ul>
*/
+ (void)deny:(NSString * _Nonnull)path;
/**
  By default, Caffeine will log whether or not Caffeine was used for a request, request URLs, HTTP methods, and response times to console. Calling this method will cause the console to cease this logging.
*/
+ (void)silenceRequestLogging;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
@end


@interface NSMutableURLRequest (SWIFT_EXTENSION(Proxeine))
@end


@interface NSURLSessionConfiguration (SWIFT_EXTENSION(Proxeine))
@end


@interface NSURLSessionConfiguration (SWIFT_EXTENSION(Proxeine))
/**
  Called on a session configuration before it’s used to instantiate an NSURLSession instance.
  This should ONLY be called if the configuration is NOT the defaultSessionConfiguration.
  Swift3:
  \code
  let configuration = URLSessionConfiguration.ephemeral
  configuration.addCaffeine()
  let session = URLSession(configuration: configuration)
  let request = URLRequest(URL: NSURL(string: "http://google.com")!)
  _ = session.dataTask(with: request) { (data, res, err) -> Void in
  print("I used Caffeine to get here")
  }.resume()

  \endcodeSwift 2.3:
  \code
  let configuration = NSURLSessionConfiguration.ephemeralSessionConfiguration()
  configuration.addCaffeine()
  let session = NSURLSession(configuration: configuration)
  let request = NSMutableURLRequest(URL: NSURL(string: "http://google.com")!)
  session.dataTaskWithRequest(request) { (data, res, err) -> Void in
  print("I used Caffeine to get here")
  }.resume()

  \endcodeObjective-C:
  \code
  NSURLSessionConfiguration *config = [NSURLSessionConfiguration ephemeralSessionConfiguration];
  [config addCaffeine];
  NSURLSession *session = [NSURLSession sessionWithConfiguration:config];
  [session dataTaskWithURL:[NSURL URLWithString:@"http://google.com"] completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
  NSLog(@"I used Caffeine to get here");
  }];

  \endcodewarning:
  The URL will NOT be Caffeinated unless it is also allowed using CaffeineHTTPProxy’s \code
  allow:
  \endcode
  seealso:
  \code
  allow:
  \endcode
*/
- (void)addCaffeine;
@end

#pragma clang diagnostic pop
